{"version":3,"file":"static/js/688.5c4c0b74.chunk.js","mappings":"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","sources":["../node_modules/three/examples/jsm/postprocessing/Pass.js","../node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js","../node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","../node_modules/three/examples/jsm/shaders/CopyShader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tColor\n} from 'three';\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nconst LuminosityHighPassShader = {\n\n\tname: 'LuminosityHighPassShader',\n\n\tshaderID: 'luminosityHighPass',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'luminosityThreshold': { value: 1.0 },\n\t\t'smoothWidth': { value: 1.0 },\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\n\t\t'defaultOpacity': { value: 0.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat v = luminance( texel.xyz );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n\n};\n\nexport { LuminosityHighPassShader };\n","import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis.basic.dispose();\n\n\t\t//\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n","/**\n * Full-screen textured quad shader\n */\n\nconst CopyShader = {\n\n\tname: 'CopyShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n"],"names":["Pass","constructor","this","isPass","enabled","needsSwap","clear","renderToScreen","setSize","render","console","error","dispose","_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","super","setAttribute","Float32BufferAttribute","_geometry","FullScreenQuad","material","_mesh","Mesh","geometry","renderer","value","LuminosityHighPassShader","name","shaderID","uniforms","Color","vertexShader","fragmentShader","UnrealBloomPass","resolution","strength","radius","threshold","undefined","Vector2","x","y","clearColor","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","WebGLRenderTarget","type","HalfFloatType","texture","generateMipmaps","i","renderTargetHorizontal","push","renderTargetVertical","highPassShader","highPassUniforms","UniformsUtils","clone","materialHighPassFilter","ShaderMaterial","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","bloomTintColors","Vector3","copyShader","CopyShader","copyUniforms","blendMaterial","blending","AdditiveBlending","depthTest","depthWrite","transparent","_oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","fsQuad","length","width","height","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","map","setRenderTarget","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","coefficients","exp","defines"],"sourceRoot":""}