{"version":3,"file":"static/js/940.51f6cda0.chunk.js","mappings":"wJAOA,MAAMA,EAELC,WAAAA,GAECC,KAAKC,QAAS,EAGdD,KAAKE,SAAU,EAGfF,KAAKG,WAAY,EAGjBH,KAAKI,OAAQ,EAGbJ,KAAKK,gBAAiB,CAEvB,CAEAC,OAAAA,GAAgC,CAEhCC,MAAAA,GAECC,QAAQC,MAAO,6DAEhB,CAEAC,OAAAA,GAAW,EAMZ,MAAMC,EAAU,IAAIC,EAAAA,KAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GAI3D,MAAMC,UAAmCC,EAAAA,IAExCf,WAAAA,GAECgB,QAEAf,KAAKgB,aAAc,WAAY,IAAIC,EAAAA,IAAwB,EAAI,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,IAClGjB,KAAKgB,aAAc,KAAM,IAAIC,EAAAA,IAAwB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,GAE5E,EAID,MAAMC,EAAY,IAAIL,EAEtB,MAAMM,EAELpB,WAAAA,CAAaqB,GAEZpB,KAAKqB,MAAQ,IAAIC,EAAAA,IAAMJ,EAAWE,EAEnC,CAEAV,OAAAA,GAECV,KAAKqB,MAAME,SAASb,SAErB,CAEAH,MAAAA,CAAQiB,GAEPA,EAASjB,OAAQP,KAAKqB,MAAOV,EAE9B,CAEA,YAAIS,GAEH,OAAOpB,KAAKqB,MAAMD,QAEnB,CAEA,YAAIA,CAAUK,GAEbzB,KAAKqB,MAAMD,SAAWK,CAEvB,E,0ECpFD,MAAMC,UAAmB5B,EAAAA,EAExBC,WAAAA,CAAa4B,EAAQC,GAEpBb,QAEAf,KAAK4B,eAA4BC,IAAdD,EAA4BA,EAAY,WAEtDD,aAAkBG,EAAAA,KAEtB9B,KAAK+B,SAAWJ,EAAOI,SAEvB/B,KAAKoB,SAAWO,GAELA,IAEX3B,KAAK+B,SAAWC,EAAAA,IAAcC,MAAON,EAAOI,UAE5C/B,KAAKoB,SAAW,IAAIU,EAAAA,IAAgB,CAEnCI,UAAwBL,IAAhBF,EAAOO,KAAuBP,EAAOO,KAAO,cACpDC,QAASC,OAAOC,OAAQ,CAAC,EAAGV,EAAOQ,SACnCJ,SAAU/B,KAAK+B,SACfO,aAAcX,EAAOW,aACrBC,eAAgBZ,EAAOY,kBAMzBvC,KAAKwC,OAAS,IAAIrB,EAAAA,EAAgBnB,KAAKoB,SAExC,CAEAb,MAAAA,CAAQiB,EAAUiB,EAAaC,GAEzB1C,KAAK+B,SAAU/B,KAAK4B,aAExB5B,KAAK+B,SAAU/B,KAAK4B,WAAYH,MAAQiB,EAAWC,SAIpD3C,KAAKwC,OAAOpB,SAAWpB,KAAKoB,SAEvBpB,KAAKK,gBAETmB,EAASoB,gBAAiB,MAC1B5C,KAAKwC,OAAOjC,OAAQiB,KAIpBA,EAASoB,gBAAiBH,GAErBzC,KAAKI,OAAQoB,EAASpB,MAAOoB,EAASqB,eAAgBrB,EAASsB,eAAgBtB,EAASuB,kBAC7F/C,KAAKwC,OAAOjC,OAAQiB,GAItB,CAEAd,OAAAA,GAECV,KAAKoB,SAASV,UAEdV,KAAKwC,OAAO9B,SAEb,E","sources":["../node_modules/three/examples/jsm/postprocessing/Pass.js","../node_modules/three/examples/jsm/postprocessing/ShaderPass.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\nclass ShaderPass extends Pass {\n\n\tconstructor( shader, textureID ) {\n\n\t\tsuper();\n\n\t\tthis.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n"],"names":["Pass","constructor","this","isPass","enabled","needsSwap","clear","renderToScreen","setSize","render","console","error","dispose","_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","super","setAttribute","Float32BufferAttribute","_geometry","FullScreenQuad","material","_mesh","Mesh","geometry","renderer","value","ShaderPass","shader","textureID","undefined","ShaderMaterial","uniforms","UniformsUtils","clone","name","defines","Object","assign","vertexShader","fragmentShader","fsQuad","writeBuffer","readBuffer","texture","setRenderTarget","autoClearColor","autoClearDepth","autoClearStencil"],"sourceRoot":""}